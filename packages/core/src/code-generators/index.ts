export interface CodeGeneratorOptions {
  language: SupportedLanguage;
  framework?: string;
  includeValidation?: boolean;
  includeComments?: boolean;
  includeTests?: boolean;
}

export type SupportedLanguage = 
  | 'typescript'
  | 'javascript'
  | 'python'
  | 'go'
  | 'rust'
  | 'java'
  | 'csharp'
  | 'ruby'
  | 'php';

export interface GeneratedCode {
  language: SupportedLanguage;
  framework?: string;
  files: GeneratedFile[];
}

export interface GeneratedFile {
  path: string;
  content: string;
  type: 'model' | 'repository' | 'service' | 'test' | 'migration';
}

export abstract class CodeGenerator {
  protected options: CodeGeneratorOptions;

  constructor(options: CodeGeneratorOptions) {
    this.options = options;
  }

  abstract generateFromSchema(schema: any): GeneratedCode;
  
  protected generateHeader(): string {
    if (!this.options.includeComments) return '';
    
    return `// Generated by Easbase
// Date: ${new Date().toISOString()}
// Language: ${this.options.language}
${this.options.framework ? `// Framework: ${this.options.framework}` : ''}

`;
  }

  protected toPascalCase(str: string): string {
    return str
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  protected toCamelCase(str: string): string {
    const pascal = this.toPascalCase(str);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
  }

  protected mapSqlType(sqlType: string, language: SupportedLanguage): string {
    const typeMap: Record<SupportedLanguage, Record<string, string>> = {
      typescript: {
        'uuid': 'string',
        'text': 'string',
        'varchar': 'string',
        'char': 'string',
        'int': 'number',
        'integer': 'number',
        'bigint': 'number',
        'decimal': 'number',
        'numeric': 'number',
        'float': 'number',
        'double': 'number',
        'boolean': 'boolean',
        'bool': 'boolean',
        'date': 'Date',
        'timestamp': 'Date',
        'timestamptz': 'Date',
        'json': 'any',
        'jsonb': 'any',
        'array': 'any[]'
      },
      python: {
        'uuid': 'str',
        'text': 'str',
        'varchar': 'str',
        'char': 'str',
        'int': 'int',
        'integer': 'int',
        'bigint': 'int',
        'decimal': 'Decimal',
        'numeric': 'Decimal',
        'float': 'float',
        'double': 'float',
        'boolean': 'bool',
        'bool': 'bool',
        'date': 'date',
        'timestamp': 'datetime',
        'timestamptz': 'datetime',
        'json': 'dict',
        'jsonb': 'dict',
        'array': 'list'
      },
      go: {
        'uuid': 'string',
        'text': 'string',
        'varchar': 'string',
        'char': 'string',
        'int': 'int32',
        'integer': 'int32',
        'bigint': 'int64',
        'decimal': 'float64',
        'numeric': 'float64',
        'float': 'float32',
        'double': 'float64',
        'boolean': 'bool',
        'bool': 'bool',
        'date': 'time.Time',
        'timestamp': 'time.Time',
        'timestamptz': 'time.Time',
        'json': 'map[string]interface{}',
        'jsonb': 'map[string]interface{}',
        'array': '[]interface{}'
      },
      rust: {
        'uuid': 'String',
        'text': 'String',
        'varchar': 'String',
        'char': 'String',
        'int': 'i32',
        'integer': 'i32',
        'bigint': 'i64',
        'decimal': 'f64',
        'numeric': 'f64',
        'float': 'f32',
        'double': 'f64',
        'boolean': 'bool',
        'bool': 'bool',
        'date': 'chrono::NaiveDate',
        'timestamp': 'chrono::NaiveDateTime',
        'timestamptz': 'chrono::DateTime<Utc>',
        'json': 'serde_json::Value',
        'jsonb': 'serde_json::Value',
        'array': 'Vec<T>'
      },
      java: {
        'uuid': 'String',
        'text': 'String',
        'varchar': 'String',
        'char': 'String',
        'int': 'Integer',
        'integer': 'Integer',
        'bigint': 'Long',
        'decimal': 'BigDecimal',
        'numeric': 'BigDecimal',
        'float': 'Float',
        'double': 'Double',
        'boolean': 'Boolean',
        'bool': 'Boolean',
        'date': 'LocalDate',
        'timestamp': 'LocalDateTime',
        'timestamptz': 'ZonedDateTime',
        'json': 'Map<String, Object>',
        'jsonb': 'Map<String, Object>',
        'array': 'List<Object>'
      },
      csharp: {
        'uuid': 'Guid',
        'text': 'string',
        'varchar': 'string',
        'char': 'string',
        'int': 'int',
        'integer': 'int',
        'bigint': 'long',
        'decimal': 'decimal',
        'numeric': 'decimal',
        'float': 'float',
        'double': 'double',
        'boolean': 'bool',
        'bool': 'bool',
        'date': 'DateTime',
        'timestamp': 'DateTime',
        'timestamptz': 'DateTimeOffset',
        'json': 'JObject',
        'jsonb': 'JObject',
        'array': 'List<object>'
      },
      ruby: {
        'uuid': 'String',
        'text': 'String',
        'varchar': 'String',
        'char': 'String',
        'int': 'Integer',
        'integer': 'Integer',
        'bigint': 'Integer',
        'decimal': 'BigDecimal',
        'numeric': 'BigDecimal',
        'float': 'Float',
        'double': 'Float',
        'boolean': 'Boolean',
        'bool': 'Boolean',
        'date': 'Date',
        'timestamp': 'DateTime',
        'timestamptz': 'DateTime',
        'json': 'Hash',
        'jsonb': 'Hash',
        'array': 'Array'
      },
      php: {
        'uuid': 'string',
        'text': 'string',
        'varchar': 'string',
        'char': 'string',
        'int': 'int',
        'integer': 'int',
        'bigint': 'int',
        'decimal': 'float',
        'numeric': 'float',
        'float': 'float',
        'double': 'float',
        'boolean': 'bool',
        'bool': 'bool',
        'date': 'DateTime',
        'timestamp': 'DateTime',
        'timestamptz': 'DateTime',
        'json': 'array',
        'jsonb': 'array',
        'array': 'array'
      },
      javascript: {
        'uuid': 'string',
        'text': 'string',
        'varchar': 'string',
        'char': 'string',
        'int': 'number',
        'integer': 'number',
        'bigint': 'number',
        'decimal': 'number',
        'numeric': 'number',
        'float': 'number',
        'double': 'number',
        'boolean': 'boolean',
        'bool': 'boolean',
        'date': 'Date',
        'timestamp': 'Date',
        'timestamptz': 'Date',
        'json': 'object',
        'jsonb': 'object',
        'array': 'Array'
      }
    };

    const baseType = sqlType.toLowerCase().split('(')[0];
    return typeMap[language][baseType] || 'any';
  }
}

// Factory to create language-specific generators
export class CodeGeneratorFactory {
  static create(options: CodeGeneratorOptions): CodeGenerator {
    switch (options.language) {
      case 'typescript':
        return new TypeScriptGenerator(options);
      case 'python':
        return new PythonGenerator(options);
      case 'go':
        return new GoGenerator(options);
      case 'rust':
        return new RustGenerator(options);
      case 'java':
        return new JavaGenerator(options);
      case 'csharp':
        return new CSharpGenerator(options);
      case 'ruby':
        return new RubyGenerator(options);
      case 'php':
        return new PHPGenerator(options);
      case 'javascript':
        return new JavaScriptGenerator(options);
      default:
        throw new Error(`Unsupported language: ${options.language}`);
    }
  }
}

// TypeScript Generator
export class TypeScriptGenerator extends CodeGenerator {
  generateFromSchema(schema: any): GeneratedCode {
    const files: GeneratedFile[] = [];
    
    // Generate model interfaces
    for (const table of schema.tables || []) {
      const modelContent = this.generateModel(table);
      files.push({
        path: `models/${this.toCamelCase(table.name)}.ts`,
        content: modelContent,
        type: 'model'
      });

      // Generate repository
      if (this.options.framework === 'nestjs') {
        const repoContent = this.generateRepository(table);
        files.push({
          path: `repositories/${this.toCamelCase(table.name)}.repository.ts`,
          content: repoContent,
          type: 'repository'
        });
      }

      // Generate tests if requested
      if (this.options.includeTests) {
        const testContent = this.generateTest(table);
        files.push({
          path: `tests/${this.toCamelCase(table.name)}.test.ts`,
          content: testContent,
          type: 'test'
        });
      }
    }

    // Generate index file
    const indexContent = this.generateIndex(schema.tables);
    files.push({
      path: 'index.ts',
      content: indexContent,
      type: 'model'
    });

    return {
      language: 'typescript',
      framework: this.options.framework,
      files
    };
  }

  private generateModel(table: any): string {
    let content = this.generateHeader();
    
    const interfaceName = this.toPascalCase(table.name);
    
    content += `export interface ${interfaceName} {\n`;
    
    for (const column of table.columns || []) {
      const propertyName = this.toCamelCase(column.name);
      const tsType = this.mapSqlType(column.type, 'typescript');
      const optional = column.nullable ? '?' : '';
      
      if (this.options.includeComments && column.description) {
        content += `  /** ${column.description} */\n`;
      }
      
      content += `  ${propertyName}${optional}: ${tsType};\n`;
    }
    
    content += '}\n';

    // Add validation schema if requested
    if (this.options.includeValidation) {
      content += `\n// Zod validation schema\n`;
      content += `import { z } from 'zod';\n\n`;
      content += `export const ${interfaceName}Schema = z.object({\n`;
      
      for (const column of table.columns || []) {
        const propertyName = this.toCamelCase(column.name);
        const zodType = this.getZodType(column.type);
        
        content += `  ${propertyName}: ${zodType}`;
        if (column.nullable) {
          content += '.nullable()';
        }
        content += ',\n';
      }
      
      content += '});\n';
      content += `\nexport type ${interfaceName}Input = z.infer<typeof ${interfaceName}Schema>;\n`;
    }

    return content;
  }

  private generateRepository(table: any): string {
    const className = this.toPascalCase(table.name) + 'Repository';
    const modelName = this.toPascalCase(table.name);
    
    return `${this.generateHeader()}
import { Injectable } from '@nestjs/common';
import { createClient } from '@supabase/supabase-js';
import { ${modelName} } from '../models/${this.toCamelCase(table.name)}';

@Injectable()
export class ${className} {
  private supabase;

  constructor() {
    this.supabase = createClient(
      process.env.SUPABASE_URL!,
      process.env.SUPABASE_KEY!
    );
  }

  async findAll(): Promise<${modelName}[]> {
    const { data, error } = await this.supabase
      .from('${table.name}')
      .select('*');
    
    if (error) throw error;
    return data;
  }

  async findById(id: string): Promise<${modelName} | null> {
    const { data, error } = await this.supabase
      .from('${table.name}')
      .select('*')
      .eq('id', id)
      .single();
    
    if (error) throw error;
    return data;
  }

  async create(data: Partial<${modelName}>): Promise<${modelName}> {
    const { data: created, error } = await this.supabase
      .from('${table.name}')
      .insert(data)
      .select()
      .single();
    
    if (error) throw error;
    return created;
  }

  async update(id: string, data: Partial<${modelName}>): Promise<${modelName}> {
    const { data: updated, error } = await this.supabase
      .from('${table.name}')
      .update(data)
      .eq('id', id)
      .select()
      .single();
    
    if (error) throw error;
    return updated;
  }

  async delete(id: string): Promise<void> {
    const { error } = await this.supabase
      .from('${table.name}')
      .delete()
      .eq('id', id);
    
    if (error) throw error;
  }
}`;
  }

  private generateTest(table: any): string {
    const modelName = this.toPascalCase(table.name);
    
    return `${this.generateHeader()}
import { describe, it, expect } from 'vitest';
import { ${modelName}Schema } from '../models/${this.toCamelCase(table.name)}';

describe('${modelName}', () => {
  it('should validate a valid ${modelName}', () => {
    const valid${modelName} = {
      ${table.columns.filter((c: any) => !c.nullable).map((c: any) => 
        `${this.toCamelCase(c.name)}: ${this.getSampleValue(c.type)}`
      ).join(',\n      ')}
    };

    const result = ${modelName}Schema.safeParse(valid${modelName});
    expect(result.success).toBe(true);
  });

  it('should reject invalid ${modelName}', () => {
    const invalid${modelName} = {
      // Missing required fields
    };

    const result = ${modelName}Schema.safeParse(invalid${modelName});
    expect(result.success).toBe(false);
  });
});`;
  }

  private generateIndex(tables: any[]): string {
    let content = this.generateHeader();
    
    for (const table of tables) {
      const fileName = this.toCamelCase(table.name);
      content += `export * from './models/${fileName}';\n`;
    }
    
    return content;
  }

  private getZodType(sqlType: string): string {
    const baseType = sqlType.toLowerCase().split('(')[0];
    
    const zodMap: Record<string, string> = {
      'uuid': 'z.string().uuid()',
      'text': 'z.string()',
      'varchar': 'z.string()',
      'int': 'z.number().int()',
      'bigint': 'z.number().int()',
      'decimal': 'z.number()',
      'boolean': 'z.boolean()',
      'date': 'z.date()',
      'timestamp': 'z.date()',
      'json': 'z.object({})',
      'jsonb': 'z.object({})'
    };
    
    return zodMap[baseType] || 'z.any()';
  }

  private getSampleValue(sqlType: string): string {
    const baseType = sqlType.toLowerCase().split('(')[0];
    
    const sampleMap: Record<string, string> = {
      'uuid': "'123e4567-e89b-12d3-a456-426614174000'",
      'text': "'Sample text'",
      'varchar': "'Sample string'",
      'int': '42',
      'bigint': '9999999',
      'decimal': '99.99',
      'boolean': 'true',
      'date': 'new Date()',
      'timestamp': 'new Date()',
      'json': '{}',
      'jsonb': '{}'
    };
    
    return sampleMap[baseType] || 'null';
  }
}

// Python Generator
export class PythonGenerator extends CodeGenerator {
  generateFromSchema(schema: any): GeneratedCode {
    const files: GeneratedFile[] = [];
    
    // Generate SQLAlchemy models
    if (this.options.framework === 'sqlalchemy') {
      const modelsContent = this.generateSQLAlchemyModels(schema);
      files.push({
        path: 'models.py',
        content: modelsContent,
        type: 'model'
      });
    }
    
    // Generate Pydantic models
    if (this.options.framework === 'fastapi' || this.options.framework === 'pydantic') {
      const schemasContent = this.generatePydanticSchemas(schema);
      files.push({
        path: 'schemas.py',
        content: schemasContent,
        type: 'model'
      });
    }
    
    // Generate Django models
    if (this.options.framework === 'django') {
      const djangoContent = this.generateDjangoModels(schema);
      files.push({
        path: 'models.py',
        content: djangoContent,
        type: 'model'
      });
    }
    
    return {
      language: 'python',
      framework: this.options.framework,
      files
    };
  }

  private generateSQLAlchemyModels(schema: any): string {
    let content = `${this.generateHeader()}
from sqlalchemy import Column, String, Integer, Boolean, DateTime, ForeignKey, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
import uuid

Base = declarative_base()

`;
    
    for (const table of schema.tables || []) {
      const className = this.toPascalCase(table.name);
      
      content += `class ${className}(Base):\n`;
      content += `    __tablename__ = '${table.name}'\n\n`;
      
      for (const column of table.columns || []) {
        const columnDef = this.getSQLAlchemyColumn(column);
        content += `    ${column.name} = ${columnDef}\n`;
      }
      
      content += '\n';
    }
    
    return content;
  }

  private generatePydanticSchemas(schema: any): string {
    let content = `${this.generateHeader()}
from pydantic import BaseModel, Field, UUID4
from typing import Optional, List
from datetime import datetime
from decimal import Decimal

`;
    
    for (const table of schema.tables || []) {
      const className = this.toPascalCase(table.name);
      
      content += `class ${className}(BaseModel):\n`;
      
      for (const column of table.columns || []) {
        const pyType = this.mapSqlType(column.type, 'python');
        const fieldType = column.nullable ? `Optional[${pyType}]` : pyType;
        
        if (column.description && this.options.includeComments) {
          content += `    # ${column.description}\n`;
        }
        
        content += `    ${column.name}: ${fieldType}`;
        
        if (column.default) {
          content += ` = Field(default=${this.getPythonDefault(column.default)})`;
        } else if (column.nullable) {
          content += ' = None';
        }
        
        content += '\n';
      }
      
      content += `\n    class Config:\n`;
      content += `        orm_mode = True\n\n`;
    }
    
    return content;
  }

  private generateDjangoModels(schema: any): string {
    let content = `${this.generateHeader()}
from django.db import models
from django.contrib.auth.models import User
import uuid

`;
    
    for (const table of schema.tables || []) {
      const className = this.toPascalCase(table.name);
      
      content += `class ${className}(models.Model):\n`;
      
      for (const column of table.columns || []) {
        const fieldDef = this.getDjangoField(column);
        content += `    ${column.name} = ${fieldDef}\n`;
      }
      
      content += `\n    class Meta:\n`;
      content += `        db_table = '${table.name}'\n`;
      content += `        verbose_name = '${className}'\n`;
      content += `        verbose_name_plural = '${className}s'\n\n`;
    }
    
    return content;
  }

  private getSQLAlchemyColumn(column: any): string {
    const typeMap: Record<string, string> = {
      'uuid': 'Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))',
      'text': 'Column(Text)',
      'varchar': 'Column(String(255))',
      'int': 'Column(Integer)',
      'boolean': 'Column(Boolean)',
      'timestamp': 'Column(DateTime)'
    };
    
    const baseType = column.type.toLowerCase().split('(')[0];
    let columnDef = typeMap[baseType] || 'Column(String)';
    
    if (column.nullable) {
      columnDef = columnDef.replace(')', ', nullable=True)');
    }
    
    return columnDef;
  }

  private getDjangoField(column: any): string {
    const typeMap: Record<string, string> = {
      'uuid': 'models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)',
      'text': 'models.TextField()',
      'varchar': 'models.CharField(max_length=255)',
      'int': 'models.IntegerField()',
      'boolean': 'models.BooleanField()',
      'timestamp': 'models.DateTimeField()'
    };
    
    const baseType = column.type.toLowerCase().split('(')[0];
    let fieldDef = typeMap[baseType] || 'models.CharField(max_length=255)';
    
    if (column.nullable) {
      fieldDef = fieldDef.replace(')', ', null=True, blank=True)');
    }
    
    return fieldDef;
  }

  private getPythonDefault(value: string): string {
    if (value === 'true' || value === 'false') {
      return value.charAt(0).toUpperCase() + value.slice(1);
    }
    if (!isNaN(Number(value))) {
      return value;
    }
    return `'${value}'`;
  }
}

// Stub implementations for other languages
export class GoGenerator extends CodeGenerator {
  generateFromSchema(schema: any): GeneratedCode {
    // Implementation for Go
    return { language: 'go', files: [] };
  }
}

export class RustGenerator extends CodeGenerator {
  generateFromSchema(schema: any): GeneratedCode {
    // Implementation for Rust
    return { language: 'rust', files: [] };
  }
}

export class JavaGenerator extends CodeGenerator {
  generateFromSchema(schema: any): GeneratedCode {
    // Implementation for Java
    return { language: 'java', files: [] };
  }
}

export class CSharpGenerator extends CodeGenerator {
  generateFromSchema(schema: any): GeneratedCode {
    // Implementation for C#
    return { language: 'csharp', files: [] };
  }
}

export class RubyGenerator extends CodeGenerator {
  generateFromSchema(schema: any): GeneratedCode {
    // Implementation for Ruby
    return { language: 'ruby', files: [] };
  }
}

export class PHPGenerator extends CodeGenerator {
  generateFromSchema(schema: any): GeneratedCode {
    // Implementation for PHP
    return { language: 'php', files: [] };
  }
}

export class JavaScriptGenerator extends CodeGenerator {
  generateFromSchema(schema: any): GeneratedCode {
    // Implementation for JavaScript
    return { language: 'javascript', files: [] };
  }
}